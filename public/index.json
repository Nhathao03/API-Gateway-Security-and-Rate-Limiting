[
{
	"uri": "//localhost:1313/",
	"title": "API Gateway Security and Rate Limiting",
	"tags": [],
	"description": "",
	"content": "Work with Amazon API Gateway Security and Rate Limiting - Session Manager Overall In this lab, you\u0026rsquo;ll learn the basics and practice of Amazon API Gateway Security and Rate Limiting - Session Manager . Perform creating public and private instance connections.\n"
},
{
	"uri": "//localhost:1313/2-deloydatabase/2.1-createdynamodbtable/",
	"title": "Create DynamoDB table",
	"tags": [],
	"description": "",
	"content": "CREATE DYNAMODB TABLE Open DynamoDB console Click Create table Enter table name: Documents Enter Parition key is user_id Enter Sort key is file In Table setting section, select Customsize setting Keep DynamoDB Standard for Table class Select On-demand for Capacity mode Scroll to the bottom of the page, click Create table "
},
{
	"uri": "//localhost:1313/2-deloydatabase/2.2-createlambdafunctions/2.2.1-createlistingfunction/",
	"title": "Create listing function",
	"tags": [],
	"description": "",
	"content": "In this section we will create a function to list the documents stored in the DynamoDB table by the user’s id.\nOpen AWS Lambda console Click Create function Enter function name: list_documents Select Python 3.9 for Runtime Click Create function Enter the following code for the lambda_function.py file: import json import boto3 import os from decimal import * from boto3.dynamodb.types import TypeDeserializer dynamodb = boto3.client(\u0026#39;dynamodb\u0026#39;) serializer = TypeDeserializer() class DecimalEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, Decimal): return str(obj) return json.JSONEncoder.default(self, obj) def deserialize(data): if isinstance(data, list): return [deserialize(v) for v in data] if isinstance(data, dict): try: return serializer.deserialize(data) except TypeError: return {k: deserialize(v) for k, v in data.items()} else: return data def lambda_handler(event, context): table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;] user_id = event[\u0026#39;pathParameters\u0026#39;][\u0026#39;id\u0026#39;] print(user_id) docs = dynamodb.query( TableName=table_name, KeyConditionExpression=\u0026#34;user_id = :id\u0026#34;, ExpressionAttributeValues={ \u0026#34;:id\u0026#34;: { \u0026#39;S\u0026#39;: user_id } } ) format_data_docs = deserialize(docs[\u0026#34;Items\u0026#34;]) # TODO implement return { \u0026#34;statusCode\u0026#34;: 200, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET,PUT,POST,DELETE, OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method,X-Access-Token,XKey,Authorization\u0026#34; }, \u0026#34;body\u0026#34;: json.dumps(format_data_docs, cls=DecimalEncoder) } Then click Deloy The above code executes to get the user’s TABLE_NAME and id environment variables from the event. Then query to the DynamoDB table provided that the value of Partition key is equal to the user’s id. Then reformat the data returned after the query.\nWe need to add an environment variable to the function. Click the Configuration tab, then select Environment variables in the left menu. Press Edit Click Add environment variable Enter TABLE_NAME as key Enter the DynamoDB table name that you just created Click Save Next, add permissions for function to access DynamoDB table Click Permission on the left menu Click on the execution role of the function Expand the AWSLambdaBasicExecutionRole… policy, then click Edit Click JSON. Copy the JSON below into the editor ,\r{\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Action\u0026#34;: [\r\u0026#34;dynamodb:Query\u0026#34;\r],\r\u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:REGION:ACCOUNT_ID:table/Documents\u0026#34;\r} Replace REGION and ACCOUNT_ID with the region you create the table and your account id.\nClick Review policy Click Save changes "
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Giới thiệu đề tài Trong bối cảnh các hệ thống hiện đại ngày càng phụ thuộc vào API để giao tiếp giữa các dịch vụ, việc đảm bảo an toàn cho các API trở thành một nhiệm vụ thiết yếu. Một API không được bảo vệ đúng cách có thể trở thành điểm yếu khiến cả hệ thống bị tấn công, gây mất dữ liệu, gián đoạn dịch vụ hoặc vi phạm tuân thủ bảo mật.\nĐề tài “API Security Gateway với Advanced Protection” hướng đến việc triển khai một kiến trúc API Gateway bảo mật cao cấp trên nền tảng AWS, tích hợp đầy đủ các lớp bảo vệ hiện đại và quy chuẩn an ninh, bao gồm:\nThreat Protection: Bảo vệ chống lại các cuộc tấn công như DDoS, SQL injection, XSS\u0026hellip; Rate Limiting: Giới hạn tốc độ truy cập API theo IP hoặc theo người dùng. Authentication: Cơ chế xác thực mạnh mẽ, hỗ trợ OAuth2, JWT, SSO\u0026hellip; Authorization: Phân quyền chi tiết theo vai trò, nhóm người dùng. Monitoring \u0026amp; Logging: Giám sát thời gian thực, alert, truy vết sự cố. Operational Readiness: Triển khai, bảo trì và quản lý vận hành thuận tiện. Developer Integration: Hỗ trợ tốt cho việc tích hợp frontend/backend và CI/CD. Mục tiêu triển khai Hướng dẫn sẽ tập trung vào việc cấu hình và triển khai các dịch vụ native của AWS để đạt được các yêu cầu sau:\nYêu cầu kỹ thuật Dịch vụ sử dụng trên AWS Threat Protection AWS Shield, AWS WAF DNS Protection + Entry Point Amazon Route 53 API Gateway Management Amazon API Gateway Authentication / Authorization Amazon Cognito, JWT, IAM Rate Limiting AWS WAF Rate-based rules, API Gateway quotas Business Logic AWS Lambda Data Storage Amazon S3, DynamoDB, Aurora Serverless Monitoring / Alerting Amazon CloudWatch, X-Ray Kiến trúc hệ thống Hệ thống được thiết kế theo hướng zero-trust, với các lớp bảo vệ theo chiều sâu từ lớp biên (network) đến ứng dụng và dữ liệu.\nNội dung blog gồm 3 phần chính Giới thiệu đề tài (bạn đang xem) Hướng dẫn triển khai chi tiết trên AWS Console: Cấu hình từng thành phần như Shield, WAF, Cognito, API Gateway, v.v. Kết nối và tích hợp giữa các dịch vụ. Dọn dẹp tài nguyên sau triển khai: Hướng dẫn xóa các dịch vụ đã sử dụng để tránh phát sinh chi phí. Yêu cầu trước khi bắt đầu Một tài khoản AWS với quyền quản trị hoặc IAM đủ quyền thao tác. Kiến thức cơ bản về REST API, bảo mật web (JWT, OAuth2, IAM). Một tên miền nếu bạn muốn cấu hình với Route 53 và CloudFront. Cài đặt sẵn AWS CLI nếu muốn thao tác kết hợp terminal. Kết luận Hướng dẫn này phù hợp cho cả:\nNhà phát triển đang xây dựng hệ thống API trên AWS DevOps hoặc Security Engineer triển khai mô hình bảo mật phân lớp Học viên hoặc kỹ sư muốn tìm hiểu kiến trúc bảo mật API hiện đại "
},
{
	"uri": "//localhost:1313/2-deloydatabase/2.2-createlambdafunctions/2.2.2-createcreatingfunction/",
	"title": "Create creating function",
	"tags": [],
	"description": "",
	"content": "This section will create a function to add document information stored in the DynamoDB table.\nOpen AWS Lambda console Click Create function Enter function name: upload_document Select Python 3.9 for Runtime Click Create function Enter the following code for the lambda_function.py file: import json import boto3 import os from datetime import datetime, timezone dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) def lambda_handler(event, context): table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;] now = datetime.now(tz=timezone.utc) dt_string = now.strftime(\u0026#34;%d/%m/%Y %H:%M:%S\u0026#34;) #doc_data = json.loads(event[\u0026#34;body\u0026#34;]) doc_data = event[\u0026#34;body\u0026#34;] path = \u0026#34;protected/{}/{}\u0026#34;.format(doc_data[\u0026#39;identityId\u0026#39;], doc_data[\u0026#39;file\u0026#39;]) doc_data.update({\u0026#34;path\u0026#34;: path, \u0026#34;modified\u0026#34;: dt_string}) table = dynamodb.Table(table_name) table.put_item(Item = doc_data) # TODO implement return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: \u0026#39;successfully upload!\u0026#39;, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Access-Control-Allow-Headers, Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method,X-Access-Token, XKey, Authorization\u0026#34;, \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET,PUT,POST,DELETE,OPTIONS\u0026#34; } } Then click Deloy The above code executes to get the user’s TABLE_NAME and id environment variables from the event. Then query to the DynamoDB table provided that the value of Partition key is equal to the user’s id. Then reformat the data returned after the query.\nWe need to add an environment variable to the function. Click the Configuration tab, then select Environment variables in the left menu. Press Edit Click Add environment variable Enter TABLE_NAME as key Enter the DynamoDB table name that you just created Click Save Next, add permissions for function to access DynamoDB table Click Permission on the left menu Click on the execution role of the function Expand the AWSLambdaBasicExecutionRole… policy, then click Edit Click JSON. Copy the JSON below into the editor ,\r{\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Action\u0026#34;: \u0026#34;dynamoDB:PutItem\u0026#34;,\r\u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:REGION:ACCOUNT_ID:table/Documents\u0026#34;\r} Replace REGION and ACCOUNT_ID with the region you create the table and your account id.\nClick Review policy Click Save changes "
},
{
	"uri": "//localhost:1313/2-deloydatabase/2.2-createlambdafunctions/",
	"title": "Create Lambda function",
	"tags": [],
	"description": "",
	"content": "Content Create listing function Create creating function Create deleting function "
},
{
	"uri": "//localhost:1313/2-deloydatabase/",
	"title": "Deloy database",
	"tags": [],
	"description": "",
	"content": "Content Create DynamoDB table Build and push image docker ECS Task Definition "
},
{
	"uri": "//localhost:1313/2-deloydatabase/2.2-createlambdafunctions/2.2.3-createdeletingfunction/",
	"title": "Create deleting function",
	"tags": [],
	"description": "",
	"content": "In this section, we will create a function to delete document information stored in the DynamoDB table by user id and filename.\nOpen AWS Lambda console Click Create function Enter function name: delete_documents Select Python 3.9 for Runtime Click Create function Enter the following code for the lambda_function.py file: import json import boto3 import os client = boto3.resource(\u0026#39;dynamodb\u0026#39;) def lambda_handler(event, context): # TODO implement table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;] error = None doc_pk = event[\u0026#39;pathParameters\u0026#39;][\u0026#39;id\u0026#39;] print(\u0026#34;doc_pk \u0026#34;, doc_pk) doc_sk = event[\u0026#39;queryStringParameters\u0026#39;][\u0026#39;file\u0026#39;] print(\u0026#34;doc_sk \u0026#34;, doc_sk) table = client.Table(table_name) key = { \u0026#39;user_id\u0026#39;:doc_pk, \u0026#39;file\u0026#39;: doc_sk } try: table.delete_item(Key = key) except Exception as e: error = e except Exception as e: error = e if error is None: message = \u0026#39;delete document successful!\u0026#39; else: print(error) message = \u0026#39;delete document fail\u0026#39; return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: message, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39; }, } Then click Deloy The above code executes to get the user’s TABLE_NAME and id environment variables from the event. Then query to the DynamoDB table provided that the value of Partition key is equal to the user’s id. Then reformat the data returned after the query.\nWe need to add an environment variable to the function. Click the Configuration tab, then select Environment variables in the left menu. Press Edit Click Add environment variable Enter TABLE_NAME as key Enter the DynamoDB table name that you just created Click Save Next, add permissions for function to access DynamoDB table Click Permission on the left menu Click on the execution role of the function Expand the AWSLambdaBasicExecutionRole… policy, then click Edit Click JSON. Copy the JSON below into the editor ,\r{\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Action\u0026#34;: \u0026#34;dynamoDB:PutItem\u0026#34;,\r\u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:REGION:ACCOUNT_ID:table/Documents\u0026#34;\r} Replace REGION and ACCOUNT_ID with the region you create the table and your account id.\nClick Review policy Click Save changes "
},
{
	"uri": "//localhost:1313/2-deloydatabase/2.3-testlambdafunctions/",
	"title": "Test lambda function",
	"tags": [],
	"description": "",
	"content": "In this section we will create tests to see if the functions are working properly.\nTo test the functions, download the following file to your computer and run the command: aws dynamodb batch-write-item --request-items file://documentData.json\n📎 Document Data\ndocumentData.json (3 KB) "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]